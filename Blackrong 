import os
import sys
import json
import socket
import random
import threading
import time
from colorama import Fore, Style, init

init(autoreset=True)

CONFIG_FILE = "ddnet_config.json"
BANNER = f"""
{Fore.CYAN}
╔═╗╔╦╗╔═╗╦  ╔═╗╦═╗╔═╗╔═╗╦  
║╣ ║║║╠═╝║  ║╣ ╠╦╝╠═╣║  ║  
╚═╝╩ ╩╩  ╩═╝╚═╝╩╚═╩ ╩╚═╝╩═╝
{Fore.YELLOW}DDNet Bot Controller v5.2
{Style.RESET_ALL}
"""

class DDNetProtocol:
    PACKET_TYPES = {
        'CONNECT': b'\x00',
        'ACCEPT': b'\x02',
        'VOTE': b'\x0a',
        'CHAT': b'\x0d'
    }

    @staticmethod
    def create_packet(packet_type, payload=b''):
        return packet_type + payload

class DDBot:
    def __init__(self, server_ip, server_port, bot_id, mode):
        self.server = (server_ip, server_port)
        self.bot_id = bot_id
        self.mode = mode
        self.running = True
        self.sock = None
        self.token = None
        self.client_id = random.randint(0, 0xFFFFFFFF)
        self.retries = 0

    def connect(self):
        while self.running and self.retries < 15:
            try:
                self._establish_connection()
                self._main_loop()
                return
            except Exception as e:
                print(f"{Fore.RED}Bot {self.bot_id} error: {str(e)}")
                self.retries += 1
                time.sleep(min(30, 2 ** self.retries))
            finally:
                if self.sock:
                    self.sock.close()

    def _establish_connection(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.settimeout(10)

        # Step 1: Initial handshake
        self.sock.sendto(
            DDNetProtocol.create_packet(DDNetProtocol.PACKET_TYPES['CONNECT']),
            self.server
        )

        # Step 2: Receive server response
        response = self.sock.recv(1024)
        if len(response) < 12:
            raise ConnectionError("Invalid handshake response")

        self.token = response[4:8]
        server_time = response[8:12]

        # Step 3: Send client info
        ack_packet = DDNetProtocol.create_packet(
            DDNetProtocol.PACKET_TYPES['ACCEPT'],
            self.token + server_time + self.client_id.to_bytes(4, 'little')
        )
        self.sock.sendto(ack_packet, self.server)

        # Step 4: Final confirmation
        final_response = self.sock.recv(1024)
        if final_response[0] != 0x02:
            raise ConnectionError("Connection rejected")

        print(f"{Fore.GREEN}Bot {self.bot_id} connected successfully!")

    def _main_loop(self):
        while self.running:
            try:
                if self.mode == 'vote':
                    self._send_vote()
                elif self.mode == 'message':
                    self._send_message()
                elif self.mode == 'spam':
                    self._send_spam()
                
                time.sleep(random.uniform(0.5, 2.0))
            except Exception as e:
                raise RuntimeError(f"Action failed: {str(e)}")

    def _send_vote(self):
        packet = DDNetProtocol.create_packet(
            DDNetProtocol.PACKET_TYPES['VOTE'],
            self.token + b'\xF3'
        )
        self.sock.sendto(packet, self.server)

    def _send_message(self):
        msg = f"Message from bot {self.bot_id}"
        packet = DDNetProtocol.create_packet(
            DDNetProtocol.PACKET_TYPES['CHAT'],
            msg.encode().ljust(64, b'\x00')
        )
        self.sock.sendto(packet, self.server)

    def _send_spam(self):
        packet = DDNetProtocol.create_packet(
            DDNetProtocol.PACKET_TYPES['CHAT'],
            os.urandom(64)
        )
        self.sock.sendto(packet, self.server)

    def stop(self):
        self.running = False

def load_config():
    default_config = {
        'server_ip': '46.174.48.103',
        'server_port': 53070,
        'mode': 'message',
        'bot_count': 20
    }
    
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE) as f:
                user_config = json.load(f)
                # Объединяем с дефолтныи значениям
                return {**default_config, **user_config}
        except json.JSONDecodeError:
            print(f"{Fore.RED}Ошибка в конфиге! Использую настройки по умолчанию")
            return default_config
    return default_config

def save_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)

def main():
    print(BANNER)
    config = load_config()
    
    # Если конфига не существует - сохраняем дефолтный
    if not os.path.exists(CONFIG_FILE):
        save_config(config)
        print(f"{Fore.YELLOW}Создан новый конфиг: {CONFIG_FILE}")

    bots = []
    try:
        print(f"{Fore.CYAN}Запускаю {config['bot_count']} ботов в режиме '{config['mode']}'...")
        for i in range(config['bot_count']):
            bot = DDBot(
                config['server_ip'],
                config['server_port'],
                i+1,
                config['mode']
            )
            thread = threading.Thread(target=bot.connect)
            bots.append((bot, thread))
            thread.start()
            time.sleep(0.1)

        input("\nНажмите Enter для остановки...")
    except KeyboardInterrupt:
        print(f"\n{Fore.RED}Прервано пользователем!")
    finally:
        print(f"\n{Fore.RED}Останавливаю ботов...")
        for bot, thread in bots:
            bot.stop()
            thread.join()
        print(f"{Fore.GREEN}Все процессы завершены!")

if __name__ == "__main__":
    main()